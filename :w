use tokio::{
    sync::{
        mpsc::{channel, Receiver, Sender as MpscSender},
        oneshot::{self, Sender},
    },
    task::JoinHandle
};

#[derive(Debug)]
pub enum ActorError {
    SendFailed,
    ResponseDropped,
}

pub enum Message {
    Add { delta: i64, reply: Sender<i64> },
    Get { reply: Sender<i64> },
    Stop { reply: Sender<()> },
}

pub struct CounterActor {
    count: i64,
    rx: Receiver<Message>,
}

impl CounterActor {
    async fn run(mut self) {
        while let Some(msg) = self.rx.recv().await {
            match msg {
                Message::Add { delta, reply } => {
                    self.count += delta;
                    let _ = reply.send(self.count);
                }
                Message::Get { reply } => { let _ = reply.send(self.count); }
                Message::Stop { reply } => { let _ = reply.send(()); break; }
            }
        }
    }
}

#[derive(Clone)]
pub struct CounterHandle {
    tx: MpscSender<Message>, 
}

impl CounterHandle {
    async fn request<T>(
        &self, 
        make_msg: impl FnOnce(oneshot::Sender<T>) -> Message
    ) -> Result<T, ActorError> {
        let (reply_tx,  reply_rx) = oneshot::channel();
        let msg = make_msg(reply_tx);
        self.tx.send(msg).await.map_err(|_| ActorError::SendFailed)?;
        reply_rx.await.map_err(|_| ActorError::ResponseDropped)
    } 

    pub async fn add(&self, delta: i64) -> Result<i64, ActorError> {
        self.request(|reply| Message::Add { delta, reply }).await
    }

    pub async fn get(&self) -> Result<i64, ActorError> {
        self.request(|reply| Message::Get { reply }).await
    }

    pub async fn stop(&self) -> Result<(), ActorError> {
        self.request(|reply| Message::Stop { reply }).await
    }
}

pub fn spawn_counter(capacity: usize) -> (CounterHandle, JoinHandle<()>) {
    let (tx, rx) = channel::<Message>(capacity);
    let actor = CounterActor { count: 0, rx };
    let join = tokio::spawn(actor.run());
    let handle = CounterHandle { tx };
    (handle, join)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_counter_add_get_happy_path() {
        let (handle, _join) = spawn_counter(8);

        let v1 = handle.add(5).await.unwrap();
        assert_eq!(v1, 5);

        let v2 = handle.add(-2).await.unwrap();
        assert_eq!(v2, 3);

        let v3 = handle.get().await.unwrap();
        assert_eq!(v3, 3);
    }

    #[tokio::test]
    async fn test_counter_stop_joins() {
        let (handle, _join) = spawn_counter(8);
        
        let stop_res = handle.stop().await;
        assert!(stop_res.is_ok());
    }
}
